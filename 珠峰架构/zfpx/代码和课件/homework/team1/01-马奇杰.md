我先简单学习一下Promise的用法

function get(x,y){

return new Promise((resolve,reject)=>{

if(x==1){

         resolve()

     }else{

         reject()

     }

 })

}

get(1).then(function(){

 console.log('success')    

})

get(2).then(function(){

 console.log('s')    

}).catch(function(){

 console.log('failed')   

})

确实很好用啊，参数是1，输出 success，参数是2，输出failed。resolve,reject都是带参数的函数，resolve(data)中的data都可传递到then的函数中，同理，reject中的参数也可传递到catch的函数中，这样就实现了参数的传递。

这样就可以实现很多异步处理了。形式的变化给人带来很多的遍历，有利于大规模的使用，避免了眼花缭乱的找回调，也利于清晰的将几个回调同步化。

function get(x,y){

return new Promise((resolve,reject)=>{

if(x==1){

         resolve('re')

     }else{

         reject()

     }

 })

}

function post(x,y){

return new Promise((resolve,reject)=>{

if(x==6){

         resolve('re')

     }else{

         reject()

     }

 })

}

Promise.all([get(1),post(6)]).then((data)=>{

 console.log(data,'all')

})

这样多个Promise就可以同时执行，写起来很清晰

下面是async await 用法

const f = () => {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(123);
        }, 2000);
    });
};

const testAsync = async () => {
    const t = await f();
    console.log(t);
    console.log(2)
};

testAsync();



它会先输出f()的返回值123，而不是输出一个其它的东东再输出1，也就是先执行了await后面函数